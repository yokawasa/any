/*
 * Automatically generated from ./simple.rpc
 * by event_rpcgen.py/0.1.  DO NOT EDIT THIS FILE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <event.h>


#include "./simple.gen.h"

void event_err(int eval, const char *fmt, ...);
void event_warn(const char *fmt, ...);
void event_errx(int eval, const char *fmt, ...);
void event_warnx(const char *fmt, ...);


/*
 * Implementation of GetUserRequest
 */

static struct GetUserRequest_access_ __GetUserRequest_base = {
  GetUserRequest_id_assign,
  GetUserRequest_id_get,
};

struct GetUserRequest *
GetUserRequest_new(void)
{
  struct GetUserRequest *tmp;
  if ((tmp = malloc(sizeof(struct GetUserRequest))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &__GetUserRequest_base;

  tmp->id_data = NULL;
  tmp->id_set = 0;

  return (tmp);
}


int
GetUserRequest_id_assign(struct GetUserRequest *msg,
    const char * value)
{
  if (msg->id_data != NULL)
    free(msg->id_data);
  if ((msg->id_data = strdup(value)) == NULL)
    return (-1);
  msg->id_set = 1;
  return (0);
}

int
GetUserRequest_id_get(struct GetUserRequest *msg, char * *value)
{
  if (msg->id_set != 1)
    return (-1);
  *value = msg->id_data;
  return (0);
}

void
GetUserRequest_clear(struct GetUserRequest *tmp)
{
  if (tmp->id_set == 1) {
    free (tmp->id_data);
    tmp->id_data = NULL;
    tmp->id_set = 0;
  }
}

void
GetUserRequest_free(struct GetUserRequest *tmp)
{
  if (tmp->id_data != NULL)
      free (tmp->id_data); 
  free(tmp);
}

void
GetUserRequest_marshal(struct evbuffer *evbuf, const struct GetUserRequest *tmp){
  evtag_marshal_string(evbuf, GETUSERREQUEST_ID, tmp->id_data);
}

int
GetUserRequest_unmarshal(struct GetUserRequest *tmp,  struct evbuffer *evbuf)
{
  uint32_t tag;
  while (EVBUFFER_LENGTH(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case GETUSERREQUEST_ID:

        if (tmp->id_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, GETUSERREQUEST_ID, &tmp->id_data) == -1) {
          event_warnx("%s: failed to unmarshal id", __func__);
          return (-1);
        }
        tmp->id_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (GetUserRequest_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
GetUserRequest_complete(struct GetUserRequest *msg)
{
  if (!msg->id_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_GetUserRequest(struct evbuffer *evbuf, uint32_t need_tag, struct GetUserRequest *msg)
{
  uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (GetUserRequest_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_GetUserRequest(struct evbuffer *evbuf, uint32_t tag, const struct GetUserRequest *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  evbuffer_drain(_buf, -1);
  GetUserRequest_marshal(_buf, msg);
  evtag_marshal(evbuf, tag, EVBUFFER_DATA(_buf), EVBUFFER_LENGTH(_buf));
  evbuffer_free(_buf);
}

/*
 * Implementation of GetUserResponse
 */

static struct GetUserResponse_access_ __GetUserResponse_base = {
  GetUserResponse_errcode_assign,
  GetUserResponse_errcode_get,
  GetUserResponse_name_assign,
  GetUserResponse_name_get,
  GetUserResponse_email_assign,
  GetUserResponse_email_get,
};

struct GetUserResponse *
GetUserResponse_new(void)
{
  struct GetUserResponse *tmp;
  if ((tmp = malloc(sizeof(struct GetUserResponse))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &__GetUserResponse_base;

  tmp->errcode_data = 0;
  tmp->errcode_set = 0;

  tmp->name_data = NULL;
  tmp->name_set = 0;

  tmp->email_data = NULL;
  tmp->email_set = 0;

  return (tmp);
}




int
GetUserResponse_errcode_assign(struct GetUserResponse *msg, const uint32_t value)
{
  msg->errcode_set = 1;
  msg->errcode_data = value;
  return (0);
}

int
GetUserResponse_name_assign(struct GetUserResponse *msg,
    const char * value)
{
  if (msg->name_data != NULL)
    free(msg->name_data);
  if ((msg->name_data = strdup(value)) == NULL)
    return (-1);
  msg->name_set = 1;
  return (0);
}

int
GetUserResponse_email_assign(struct GetUserResponse *msg,
    const char * value)
{
  if (msg->email_data != NULL)
    free(msg->email_data);
  if ((msg->email_data = strdup(value)) == NULL)
    return (-1);
  msg->email_set = 1;
  return (0);
}

int
GetUserResponse_errcode_get(struct GetUserResponse *msg, uint32_t *value)
{
  if (msg->errcode_set != 1)
    return (-1);
  *value = msg->errcode_data;
  return (0);
}

int
GetUserResponse_name_get(struct GetUserResponse *msg, char * *value)
{
  if (msg->name_set != 1)
    return (-1);
  *value = msg->name_data;
  return (0);
}

int
GetUserResponse_email_get(struct GetUserResponse *msg, char * *value)
{
  if (msg->email_set != 1)
    return (-1);
  *value = msg->email_data;
  return (0);
}

void
GetUserResponse_clear(struct GetUserResponse *tmp)
{
  tmp->errcode_set = 0;
  if (tmp->name_set == 1) {
    free (tmp->name_data);
    tmp->name_data = NULL;
    tmp->name_set = 0;
  }
  if (tmp->email_set == 1) {
    free (tmp->email_data);
    tmp->email_data = NULL;
    tmp->email_set = 0;
  }
}

void
GetUserResponse_free(struct GetUserResponse *tmp)
{
  if (tmp->name_data != NULL)
      free (tmp->name_data); 
  if (tmp->email_data != NULL)
      free (tmp->email_data); 
  free(tmp);
}

void
GetUserResponse_marshal(struct evbuffer *evbuf, const struct GetUserResponse *tmp){
  evtag_marshal_int(evbuf, GETUSERRESPONSE_ERRCODE, tmp->errcode_data);
  if (tmp->name_set) {
    evtag_marshal_string(evbuf, GETUSERRESPONSE_NAME, tmp->name_data);
  }
  if (tmp->email_set) {
    evtag_marshal_string(evbuf, GETUSERRESPONSE_EMAIL, tmp->email_data);
  }
}

int
GetUserResponse_unmarshal(struct GetUserResponse *tmp,  struct evbuffer *evbuf)
{
  uint32_t tag;
  while (EVBUFFER_LENGTH(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case GETUSERRESPONSE_ERRCODE:

        if (tmp->errcode_set)
          return (-1);
        if (evtag_unmarshal_int(evbuf, GETUSERRESPONSE_ERRCODE, &tmp->errcode_data) == -1) {
          event_warnx("%s: failed to unmarshal errcode", __func__);
          return (-1);
        }
        tmp->errcode_set = 1;
        break;

      case GETUSERRESPONSE_NAME:

        if (tmp->name_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, GETUSERRESPONSE_NAME, &tmp->name_data) == -1) {
          event_warnx("%s: failed to unmarshal name", __func__);
          return (-1);
        }
        tmp->name_set = 1;
        break;

      case GETUSERRESPONSE_EMAIL:

        if (tmp->email_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, GETUSERRESPONSE_EMAIL, &tmp->email_data) == -1) {
          event_warnx("%s: failed to unmarshal email", __func__);
          return (-1);
        }
        tmp->email_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (GetUserResponse_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
GetUserResponse_complete(struct GetUserResponse *msg)
{
  if (!msg->errcode_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_GetUserResponse(struct evbuffer *evbuf, uint32_t need_tag, struct GetUserResponse *msg)
{
  uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (GetUserResponse_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_GetUserResponse(struct evbuffer *evbuf, uint32_t tag, const struct GetUserResponse *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  evbuffer_drain(_buf, -1);
  GetUserResponse_marshal(_buf, msg);
  evtag_marshal(evbuf, tag, EVBUFFER_DATA(_buf), EVBUFFER_LENGTH(_buf));
  evbuffer_free(_buf);
}

